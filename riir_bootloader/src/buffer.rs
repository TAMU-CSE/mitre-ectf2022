use crate::error::{Error, Result};
use crate::peripherals::uart::FRAME_OK;
use crate::peripherals::{Flash, Uart};
use crate::size;
use core::ops::{Deref, DerefMut};
use heapless::Vec;

/// Size of MAC generated by [`crypto_secretstream`]
pub const MAC_LEN: usize = 16;
/// Size of tag generated by [`crypto_secretstream`]
pub const TAG_LEN: usize = 1;
/// Maximum size of cryptographic metadata generated by [`crypto_secretstream`]
pub const CRYPTO_META_LEN: usize = MAC_LEN + TAG_LEN;
/// Maximum size of a chunk encrypted with [`crypto_secretstream`].
pub const MAX_CIPHERTEXT_CHUNK_LEN: usize = Flash::PAGE_SIZE + CRYPTO_META_LEN;

/// General-purpose buffer for incrementally decrypting and flashing data.
#[repr(align(4))]
pub struct Buffer(Vec<u8, { MAX_CIPHERTEXT_CHUNK_LEN as usize }>);

impl Buffer {
    /// Creates a new [`Buffer`].
    #[link_section = ".data"]
    pub fn new() -> Self {
        Self(Vec::new())
    }
    #[link_section = ".data"]
    /// Pads the buffer with `0xFF` until the buffer's length is a multiple of 4.
    fn align_to_u32(&mut self) -> Result<()> {
        let padding_len = (size!(u32) - (self.0.len() % size!(u32))) % size!(u32);
        for _ in 0..padding_len {
            self.0.push(0xff).map_err(|_| Error::CapacityOverflow)?;
        }
        Ok(())
    }
    /// Pads the buffer with `0xFF` until the buffer's length is a multiple of 4, then
    /// returns the buffer's contents as a slice of [`u32`] for flashing.
    #[link_section = ".data"]
    pub fn padded_flash_words(&mut self) -> Result<&[u32]> {
        self.align_to_u32()?;
        let ptr = self.0.as_ptr() as *const u32;
        let len = self.0.len() / size!(u32);
        // SAFETY: The contents of the buffer are guaranteed to be a multiple of 4
        // by align_to_u32(), and the buffer itself has an alignment of 4, so this
        // is sound.
        unsafe { Ok(core::slice::from_raw_parts(ptr, len)) }
    }
    #[link_section = ".data"]
    /// Clears the buffer, then fills it with `n` bytes from UART. Fails if `n`
    /// exceeds the size of the buffer.
    pub fn fill_from_uart(&mut self, uart: &mut Uart, n: usize) -> Result<()> {
        self.0.clear();
        uart.write_u8(FRAME_OK);
        for _ in 0..n {
            self.0
                .push(uart.nonblocking_read_u8()?)
                .map_err(|_| Error::CapacityOverflow)?;
        }
        Ok(())
    }
    /// Extends the buffer from the provided slice. Fails if the slice does not fit in the
    /// buffer.
    #[link_section = ".data"]
    pub fn extend_from_slice(&mut self, slice: &[u8]) -> Result<()> {
        self.0
            .extend_from_slice(slice)
            .map_err(|_| Error::CapacityOverflow)
    }
}

/// These trait implementations are required to workaround the fact that we're using a fork of
/// [`heapless`] ([`aead::Buffer`] is no longer implemented for [`heapless::Vec`]).
impl AsRef<[u8]> for Buffer {
    fn as_ref(&self) -> &[u8] {
        self.0.as_ref()
    }
}

impl AsMut<[u8]> for Buffer {
    fn as_mut(&mut self) -> &mut [u8] {
        self.0.as_mut()
    }
}

impl aead::Buffer for Buffer {
    fn extend_from_slice(&mut self, other: &[u8]) -> aead::Result<()> {
        self.0.extend_from_slice(other).map_err(|_| aead::Error)
    }
    fn truncate(&mut self, len: usize) {
        self.0.truncate(len);
    }
}

impl Deref for Buffer {
    type Target = heapless::Vec<u8, { MAX_CIPHERTEXT_CHUNK_LEN as usize }>;
    #[link_section = ".data"]
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl DerefMut for Buffer {
    #[link_section = ".data"]
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
